------------HammingDistance------------
	"^"是一种逻辑运算符---按位异或
n&(n-1)的妙用
	1、将n的二进制表示中的最低位为1的改为0.
它的应用：
	1、求一个数的二进制表示中的个数
	while (n >0 )
	{
      count ++;
      n &= (n-1);
	}
	2、判断一个数是否是2的方幂
	n>0&&((n&(n-1))==0)
	3、计算N!的质因数2的个数
	
------------Complex Number Multiplication------
	1、string a=s.substr(0,5);       //获得字符串s中 从第0位开始的长度为5的字符串//默认时的长度为从开始位置到尾
	
------------Number Complement------------------
	1、求反码
	将二进制 1 一位位的向左移与之异或，这样原码中的1变为0,0变为1，从而求得反码。
	2、按位取反 与 当前数的最高位变0，右边低位全为1，这样就可以得到反码
	
------------Reverse Words in a String III---------
	1、使用stl中的reverse方法。
	2、自己用C语言写一个stl中的reverse方法
	
------------Add Two Numbers(链表实现数字相加)-------------
	1、public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode prev = new ListNode(0);
    ListNode head = prev;
    int carry = 0;
    while (l1 != null || l2 != null || carry != 0) {
        ListNode cur = new ListNode(0);
        int sum = ((l2 == null) ? 0 : l2.val) + ((l1 == null) ? 0 : l1.val) + carry;
        cur.val = sum % 10;
        carry = sum / 10;
        prev.next = cur;
        prev = cur;
        l1 = (l1 == null) ? l1 : l1.next;
        l2 = (l2 == null) ? l2 : l2.next;
    }
    return head.next;
	}
	
	2、ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
    ListNode preHead(0), *p = &preHead;
    int extra = 0;
    while (l1 || l2 || extra) {
        int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + extra;
        extra = sum / 10;
        p->next = new ListNode(sum % 10);
        p = p->next;
        l1 = l1 ? l1->next : l1;
        l2 = l2 ? l2->next : l2;
    }
    return preHead.next;
}
	其实两种算法基本一致，第二种可能更简洁一些。
------------Add Two Numbers II（将链表从后往前相加）-----------------
    1、ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2; // store digits in stack
        for (; l1; l1 = l1->next) s1.push(l1->val); 
        for (; l2; l2 = l2->next) s2.push(l2->val);
        
        ListNode *res = new ListNode(0), *tmp = NULL;
        for (int sum = 0; !s1.empty()||!s2.empty(); tmp = new ListNode(sum/=10), tmp->next = res, res = tmp) {
            if (!s1.empty()) sum += s1.top(), s1.pop(); // get digit sum
            if (!s2.empty()) sum += s2.top(), s2.pop();
            res->val = sum%10;
        }
        return res->val? res : res->next;        
    }
	2、 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {       
      ListNode ans=NULL;
        Stack<ListNode> stack1=new Stack<ListNode>(),stack2=new Stack<ListNode>();
        //invariant
        while(l1!=NULL||l2!=NULL){
            if(l1!=NULL){
                stack1.push(l1);
                l1=l1.next;
            }
            if(l2!=NULL){
                stack2.push(l2);
                l2=l2.next;
            }
        }
        int a=0,b=0,carry=0,sum=0;
        while(!stack1.isEmpty()||!stack2.isEmpty()||carry){
            if(!stack1.isEmpty())
                a=stack1.pop().val;
            else
                a=0;
            if(!stack2.isEmpty())
                b=stack2.pop().val;
            else
                b=0;
            sum=a+b+carry;
            ListNode tmp=new ListNode(sum%10);
            tmp.next=ans;
            ans=tmp;
            carry=sum/10;
        }
        //ensure
        return ans;
    }
-------------